// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package gitlab

import (
	"github.com/xanzy/go-gitlab"
	"sync"
)

var (
	lockClientMockloadDiscussions   sync.RWMutex
	lockClientMockloadEmojis        sync.RWMutex
	lockClientMockopenMergeRequests sync.RWMutex
	lockClientMockprojectInfo       sync.RWMutex
)

// Ensure, that ClientMock does implement Client.
// If this is not the case, regenerate this file with moq.
var _ Client = &ClientMock{}

// ClientMock is a mock implementation of Client.
//
//     func TestSomethingThatUsesClient(t *testing.T) {
//
//         // make and configure a mocked Client
//         mockedClient := &ClientMock{
//             loadDiscussionsFunc: func(projectID int, mr *gitlab.MergeRequest) []*gitlab.Discussion {
// 	               panic("mock out the loadDiscussions method")
//             },
//             loadEmojisFunc: func(projectID int, mr *gitlab.MergeRequest) []*gitlab.AwardEmoji {
// 	               panic("mock out the loadEmojis method")
//             },
//             openMergeRequestsFunc: func(projectID int) []*gitlab.MergeRequest {
// 	               panic("mock out the openMergeRequests method")
//             },
//             projectInfoFunc: func(id int) gitlab.Project {
// 	               panic("mock out the projectInfo method")
//             },
//         }
//
//         // use mockedClient in code that requires Client
//         // and then make assertions.
//
//     }
type ClientMock struct {
	// loadDiscussionsFunc mocks the loadDiscussions method.
	loadDiscussionsFunc func(projectID int, mr *gitlab.MergeRequest) []*gitlab.Discussion

	// loadEmojisFunc mocks the loadEmojis method.
	loadEmojisFunc func(projectID int, mr *gitlab.MergeRequest) []*gitlab.AwardEmoji

	// openMergeRequestsFunc mocks the openMergeRequests method.
	openMergeRequestsFunc func(projectID int) []*gitlab.MergeRequest

	// projectInfoFunc mocks the projectInfo method.
	projectInfoFunc func(id int) gitlab.Project

	// calls tracks calls to the methods.
	calls struct {
		// loadDiscussions holds details about calls to the loadDiscussions method.
		loadDiscussions []struct {
			// ProjectID is the projectID argument value.
			ProjectID int
			// Mr is the mr argument value.
			Mr *gitlab.MergeRequest
		}
		// loadEmojis holds details about calls to the loadEmojis method.
		loadEmojis []struct {
			// ProjectID is the projectID argument value.
			ProjectID int
			// Mr is the mr argument value.
			Mr *gitlab.MergeRequest
		}
		// openMergeRequests holds details about calls to the openMergeRequests method.
		openMergeRequests []struct {
			// ProjectID is the projectID argument value.
			ProjectID int
		}
		// projectInfo holds details about calls to the projectInfo method.
		projectInfo []struct {
			// ID is the id argument value.
			ID int
		}
	}
}

// loadDiscussions calls loadDiscussionsFunc.
func (mock *ClientMock) loadDiscussions(projectID int, mr *gitlab.MergeRequest) []*gitlab.Discussion {
	if mock.loadDiscussionsFunc == nil {
		panic("ClientMock.loadDiscussionsFunc: method is nil but Client.loadDiscussions was just called")
	}
	callInfo := struct {
		ProjectID int
		Mr        *gitlab.MergeRequest
	}{
		ProjectID: projectID,
		Mr:        mr,
	}
	lockClientMockloadDiscussions.Lock()
	mock.calls.loadDiscussions = append(mock.calls.loadDiscussions, callInfo)
	lockClientMockloadDiscussions.Unlock()
	return mock.loadDiscussionsFunc(projectID, mr)
}

// loadDiscussionsCalls gets all the calls that were made to loadDiscussions.
// Check the length with:
//     len(mockedClient.loadDiscussionsCalls())
func (mock *ClientMock) loadDiscussionsCalls() []struct {
	ProjectID int
	Mr        *gitlab.MergeRequest
} {
	var calls []struct {
		ProjectID int
		Mr        *gitlab.MergeRequest
	}
	lockClientMockloadDiscussions.RLock()
	calls = mock.calls.loadDiscussions
	lockClientMockloadDiscussions.RUnlock()
	return calls
}

// loadEmojis calls loadEmojisFunc.
func (mock *ClientMock) loadEmojis(projectID int, mr *gitlab.MergeRequest) []*gitlab.AwardEmoji {
	if mock.loadEmojisFunc == nil {
		panic("ClientMock.loadEmojisFunc: method is nil but Client.loadEmojis was just called")
	}
	callInfo := struct {
		ProjectID int
		Mr        *gitlab.MergeRequest
	}{
		ProjectID: projectID,
		Mr:        mr,
	}
	lockClientMockloadEmojis.Lock()
	mock.calls.loadEmojis = append(mock.calls.loadEmojis, callInfo)
	lockClientMockloadEmojis.Unlock()
	return mock.loadEmojisFunc(projectID, mr)
}

// loadEmojisCalls gets all the calls that were made to loadEmojis.
// Check the length with:
//     len(mockedClient.loadEmojisCalls())
func (mock *ClientMock) loadEmojisCalls() []struct {
	ProjectID int
	Mr        *gitlab.MergeRequest
} {
	var calls []struct {
		ProjectID int
		Mr        *gitlab.MergeRequest
	}
	lockClientMockloadEmojis.RLock()
	calls = mock.calls.loadEmojis
	lockClientMockloadEmojis.RUnlock()
	return calls
}

// openMergeRequests calls openMergeRequestsFunc.
func (mock *ClientMock) openMergeRequests(projectID int) []*gitlab.MergeRequest {
	if mock.openMergeRequestsFunc == nil {
		panic("ClientMock.openMergeRequestsFunc: method is nil but Client.openMergeRequests was just called")
	}
	callInfo := struct {
		ProjectID int
	}{
		ProjectID: projectID,
	}
	lockClientMockopenMergeRequests.Lock()
	mock.calls.openMergeRequests = append(mock.calls.openMergeRequests, callInfo)
	lockClientMockopenMergeRequests.Unlock()
	return mock.openMergeRequestsFunc(projectID)
}

// openMergeRequestsCalls gets all the calls that were made to openMergeRequests.
// Check the length with:
//     len(mockedClient.openMergeRequestsCalls())
func (mock *ClientMock) openMergeRequestsCalls() []struct {
	ProjectID int
} {
	var calls []struct {
		ProjectID int
	}
	lockClientMockopenMergeRequests.RLock()
	calls = mock.calls.openMergeRequests
	lockClientMockopenMergeRequests.RUnlock()
	return calls
}

// projectInfo calls projectInfoFunc.
func (mock *ClientMock) projectInfo(id int) gitlab.Project {
	if mock.projectInfoFunc == nil {
		panic("ClientMock.projectInfoFunc: method is nil but Client.projectInfo was just called")
	}
	callInfo := struct {
		ID int
	}{
		ID: id,
	}
	lockClientMockprojectInfo.Lock()
	mock.calls.projectInfo = append(mock.calls.projectInfo, callInfo)
	lockClientMockprojectInfo.Unlock()
	return mock.projectInfoFunc(id)
}

// projectInfoCalls gets all the calls that were made to projectInfo.
// Check the length with:
//     len(mockedClient.projectInfoCalls())
func (mock *ClientMock) projectInfoCalls() []struct {
	ID int
} {
	var calls []struct {
		ID int
	}
	lockClientMockprojectInfo.RLock()
	calls = mock.calls.projectInfo
	lockClientMockprojectInfo.RUnlock()
	return calls
}
