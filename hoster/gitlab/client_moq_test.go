// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package gitlab

import (
	"github.com/xanzy/go-gitlab"
	"sync"
)

var (
	lockclientMockloadDiscussions   sync.RWMutex
	lockclientMockloadEmojis        sync.RWMutex
	lockclientMockopenMergeRequests sync.RWMutex
	lockclientMockprojectInfo       sync.RWMutex
)

// Ensure, that clientMock does implement client.
// If this is not the case, regenerate this file with moq.
var _ client = &clientMock{}

// clientMock is a mock implementation of client.
//
//     func TestSomethingThatUsesclient(t *testing.T) {
//
//         // make and configure a mocked client
//         mockedclient := &clientMock{
//             loadDiscussionsFunc: func(repo interface{}, mr *gitlab.MergeRequest) []*gitlab.Discussion {
// 	               panic("mock out the loadDiscussions method")
//             },
//             loadEmojisFunc: func(repo interface{}, mr *gitlab.MergeRequest) []*gitlab.AwardEmoji {
// 	               panic("mock out the loadEmojis method")
//             },
//             openMergeRequestsFunc: func(repo interface{}) []*gitlab.MergeRequest {
// 	               panic("mock out the openMergeRequests method")
//             },
//             projectInfoFunc: func(repo interface{}) gitlab.Project {
// 	               panic("mock out the projectInfo method")
//             },
//         }
//
//         // use mockedclient in code that requires client
//         // and then make assertions.
//
//     }
type clientMock struct {
	// loadDiscussionsFunc mocks the loadDiscussions method.
	loadDiscussionsFunc func(repo interface{}, mr *gitlab.MergeRequest) []*gitlab.Discussion

	// loadEmojisFunc mocks the loadEmojis method.
	loadEmojisFunc func(repo interface{}, mr *gitlab.MergeRequest) []*gitlab.AwardEmoji

	// openMergeRequestsFunc mocks the openMergeRequests method.
	openMergeRequestsFunc func(repo interface{}) []*gitlab.MergeRequest

	// projectInfoFunc mocks the projectInfo method.
	projectInfoFunc func(repo interface{}) gitlab.Project

	// calls tracks calls to the methods.
	calls struct {
		// loadDiscussions holds details about calls to the loadDiscussions method.
		loadDiscussions []struct {
			// Repo is the repo argument value.
			Repo interface{}
			// Mr is the mr argument value.
			Mr *gitlab.MergeRequest
		}
		// loadEmojis holds details about calls to the loadEmojis method.
		loadEmojis []struct {
			// Repo is the repo argument value.
			Repo interface{}
			// Mr is the mr argument value.
			Mr *gitlab.MergeRequest
		}
		// openMergeRequests holds details about calls to the openMergeRequests method.
		openMergeRequests []struct {
			// Repo is the repo argument value.
			Repo interface{}
		}
		// projectInfo holds details about calls to the projectInfo method.
		projectInfo []struct {
			// Repo is the repo argument value.
			Repo interface{}
		}
	}
}

// loadDiscussions calls loadDiscussionsFunc.
func (mock *clientMock) loadDiscussions(repo interface{}, mr *gitlab.MergeRequest) []*gitlab.Discussion {
	if mock.loadDiscussionsFunc == nil {
		panic("clientMock.loadDiscussionsFunc: method is nil but client.loadDiscussions was just called")
	}
	callInfo := struct {
		Repo interface{}
		Mr   *gitlab.MergeRequest
	}{
		Repo: repo,
		Mr:   mr,
	}
	lockclientMockloadDiscussions.Lock()
	mock.calls.loadDiscussions = append(mock.calls.loadDiscussions, callInfo)
	lockclientMockloadDiscussions.Unlock()
	return mock.loadDiscussionsFunc(repo, mr)
}

// loadDiscussionsCalls gets all the calls that were made to loadDiscussions.
// Check the length with:
//     len(mockedclient.loadDiscussionsCalls())
func (mock *clientMock) loadDiscussionsCalls() []struct {
	Repo interface{}
	Mr   *gitlab.MergeRequest
} {
	var calls []struct {
		Repo interface{}
		Mr   *gitlab.MergeRequest
	}
	lockclientMockloadDiscussions.RLock()
	calls = mock.calls.loadDiscussions
	lockclientMockloadDiscussions.RUnlock()
	return calls
}

// loadEmojis calls loadEmojisFunc.
func (mock *clientMock) loadEmojis(repo interface{}, mr *gitlab.MergeRequest) []*gitlab.AwardEmoji {
	if mock.loadEmojisFunc == nil {
		panic("clientMock.loadEmojisFunc: method is nil but client.loadEmojis was just called")
	}
	callInfo := struct {
		Repo interface{}
		Mr   *gitlab.MergeRequest
	}{
		Repo: repo,
		Mr:   mr,
	}
	lockclientMockloadEmojis.Lock()
	mock.calls.loadEmojis = append(mock.calls.loadEmojis, callInfo)
	lockclientMockloadEmojis.Unlock()
	return mock.loadEmojisFunc(repo, mr)
}

// loadEmojisCalls gets all the calls that were made to loadEmojis.
// Check the length with:
//     len(mockedclient.loadEmojisCalls())
func (mock *clientMock) loadEmojisCalls() []struct {
	Repo interface{}
	Mr   *gitlab.MergeRequest
} {
	var calls []struct {
		Repo interface{}
		Mr   *gitlab.MergeRequest
	}
	lockclientMockloadEmojis.RLock()
	calls = mock.calls.loadEmojis
	lockclientMockloadEmojis.RUnlock()
	return calls
}

// openMergeRequests calls openMergeRequestsFunc.
func (mock *clientMock) openMergeRequests(repo interface{}) []*gitlab.MergeRequest {
	if mock.openMergeRequestsFunc == nil {
		panic("clientMock.openMergeRequestsFunc: method is nil but client.openMergeRequests was just called")
	}
	callInfo := struct {
		Repo interface{}
	}{
		Repo: repo,
	}
	lockclientMockopenMergeRequests.Lock()
	mock.calls.openMergeRequests = append(mock.calls.openMergeRequests, callInfo)
	lockclientMockopenMergeRequests.Unlock()
	return mock.openMergeRequestsFunc(repo)
}

// openMergeRequestsCalls gets all the calls that were made to openMergeRequests.
// Check the length with:
//     len(mockedclient.openMergeRequestsCalls())
func (mock *clientMock) openMergeRequestsCalls() []struct {
	Repo interface{}
} {
	var calls []struct {
		Repo interface{}
	}
	lockclientMockopenMergeRequests.RLock()
	calls = mock.calls.openMergeRequests
	lockclientMockopenMergeRequests.RUnlock()
	return calls
}

// projectInfo calls projectInfoFunc.
func (mock *clientMock) projectInfo(repo interface{}) gitlab.Project {
	if mock.projectInfoFunc == nil {
		panic("clientMock.projectInfoFunc: method is nil but client.projectInfo was just called")
	}
	callInfo := struct {
		Repo interface{}
	}{
		Repo: repo,
	}
	lockclientMockprojectInfo.Lock()
	mock.calls.projectInfo = append(mock.calls.projectInfo, callInfo)
	lockclientMockprojectInfo.Unlock()
	return mock.projectInfoFunc(repo)
}

// projectInfoCalls gets all the calls that were made to projectInfo.
// Check the length with:
//     len(mockedclient.projectInfoCalls())
func (mock *clientMock) projectInfoCalls() []struct {
	Repo interface{}
} {
	var calls []struct {
		Repo interface{}
	}
	lockclientMockprojectInfo.RLock()
	calls = mock.calls.projectInfo
	lockclientMockprojectInfo.RUnlock()
	return calls
}
