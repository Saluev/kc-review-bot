// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package gitlab

import (
	"github.com/xanzy/go-gitlab"
	"sync"
)

var (
	lockclientWrapperMockloadDiscussions sync.RWMutex
	lockclientWrapperMockloadEmojis      sync.RWMutex
	lockclientWrapperMockloadMRs         sync.RWMutex
	lockclientWrapperMockloadProject     sync.RWMutex
)

// Ensure, that clientWrapperMock does implement clientWrapper.
// If this is not the case, regenerate this file with moq.
var _ clientWrapper = &clientWrapperMock{}

// clientWrapperMock is a mock implementation of clientWrapper.
//
//     func TestSomethingThatUsesclientWrapper(t *testing.T) {
//
//         // make and configure a mocked clientWrapper
//         mockedclientWrapper := &clientWrapperMock{
//             loadDiscussionsFunc: func(repo interface{}, mr *gitlab.MergeRequest) []*gitlab.Discussion {
// 	               panic("mock out the loadDiscussions method")
//             },
//             loadEmojisFunc: func(repo interface{}, mr *gitlab.MergeRequest) []*gitlab.AwardEmoji {
// 	               panic("mock out the loadEmojis method")
//             },
//             loadMRsFunc: func(repo interface{}) []*gitlab.MergeRequest {
// 	               panic("mock out the loadMRs method")
//             },
//             loadProjectFunc: func(repo interface{}) gitlab.Project {
// 	               panic("mock out the loadProject method")
//             },
//         }
//
//         // use mockedclientWrapper in code that requires clientWrapper
//         // and then make assertions.
//
//     }
type clientWrapperMock struct {
	// loadDiscussionsFunc mocks the loadDiscussions method.
	loadDiscussionsFunc func(repo interface{}, mr *gitlab.MergeRequest) []*gitlab.Discussion

	// loadEmojisFunc mocks the loadEmojis method.
	loadEmojisFunc func(repo interface{}, mr *gitlab.MergeRequest) []*gitlab.AwardEmoji

	// loadMRsFunc mocks the loadMRs method.
	loadMRsFunc func(repo interface{}) []*gitlab.MergeRequest

	// loadProjectFunc mocks the loadProject method.
	loadProjectFunc func(repo interface{}) gitlab.Project

	// calls tracks calls to the methods.
	calls struct {
		// loadDiscussions holds details about calls to the loadDiscussions method.
		loadDiscussions []struct {
			// Repo is the repo argument value.
			Repo interface{}
			// Mr is the mr argument value.
			Mr *gitlab.MergeRequest
		}
		// loadEmojis holds details about calls to the loadEmojis method.
		loadEmojis []struct {
			// Repo is the repo argument value.
			Repo interface{}
			// Mr is the mr argument value.
			Mr *gitlab.MergeRequest
		}
		// loadMRs holds details about calls to the loadMRs method.
		loadMRs []struct {
			// Repo is the repo argument value.
			Repo interface{}
		}
		// loadProject holds details about calls to the loadProject method.
		loadProject []struct {
			// Repo is the repo argument value.
			Repo interface{}
		}
	}
}

// loadDiscussions calls loadDiscussionsFunc.
func (mock *clientWrapperMock) loadDiscussions(repo interface{}, mr *gitlab.MergeRequest) []*gitlab.Discussion {
	if mock.loadDiscussionsFunc == nil {
		panic("clientWrapperMock.loadDiscussionsFunc: method is nil but clientWrapper.loadDiscussions was just called")
	}
	callInfo := struct {
		Repo interface{}
		Mr   *gitlab.MergeRequest
	}{
		Repo: repo,
		Mr:   mr,
	}
	lockclientWrapperMockloadDiscussions.Lock()
	mock.calls.loadDiscussions = append(mock.calls.loadDiscussions, callInfo)
	lockclientWrapperMockloadDiscussions.Unlock()
	return mock.loadDiscussionsFunc(repo, mr)
}

// loadDiscussionsCalls gets all the calls that were made to loadDiscussions.
// Check the length with:
//     len(mockedclientWrapper.loadDiscussionsCalls())
func (mock *clientWrapperMock) loadDiscussionsCalls() []struct {
	Repo interface{}
	Mr   *gitlab.MergeRequest
} {
	var calls []struct {
		Repo interface{}
		Mr   *gitlab.MergeRequest
	}
	lockclientWrapperMockloadDiscussions.RLock()
	calls = mock.calls.loadDiscussions
	lockclientWrapperMockloadDiscussions.RUnlock()
	return calls
}

// loadEmojis calls loadEmojisFunc.
func (mock *clientWrapperMock) loadEmojis(repo interface{}, mr *gitlab.MergeRequest) []*gitlab.AwardEmoji {
	if mock.loadEmojisFunc == nil {
		panic("clientWrapperMock.loadEmojisFunc: method is nil but clientWrapper.loadEmojis was just called")
	}
	callInfo := struct {
		Repo interface{}
		Mr   *gitlab.MergeRequest
	}{
		Repo: repo,
		Mr:   mr,
	}
	lockclientWrapperMockloadEmojis.Lock()
	mock.calls.loadEmojis = append(mock.calls.loadEmojis, callInfo)
	lockclientWrapperMockloadEmojis.Unlock()
	return mock.loadEmojisFunc(repo, mr)
}

// loadEmojisCalls gets all the calls that were made to loadEmojis.
// Check the length with:
//     len(mockedclientWrapper.loadEmojisCalls())
func (mock *clientWrapperMock) loadEmojisCalls() []struct {
	Repo interface{}
	Mr   *gitlab.MergeRequest
} {
	var calls []struct {
		Repo interface{}
		Mr   *gitlab.MergeRequest
	}
	lockclientWrapperMockloadEmojis.RLock()
	calls = mock.calls.loadEmojis
	lockclientWrapperMockloadEmojis.RUnlock()
	return calls
}

// loadMRs calls loadMRsFunc.
func (mock *clientWrapperMock) loadMRs(repo interface{}) []*gitlab.MergeRequest {
	if mock.loadMRsFunc == nil {
		panic("clientWrapperMock.loadMRsFunc: method is nil but clientWrapper.loadMRs was just called")
	}
	callInfo := struct {
		Repo interface{}
	}{
		Repo: repo,
	}
	lockclientWrapperMockloadMRs.Lock()
	mock.calls.loadMRs = append(mock.calls.loadMRs, callInfo)
	lockclientWrapperMockloadMRs.Unlock()
	return mock.loadMRsFunc(repo)
}

// loadMRsCalls gets all the calls that were made to loadMRs.
// Check the length with:
//     len(mockedclientWrapper.loadMRsCalls())
func (mock *clientWrapperMock) loadMRsCalls() []struct {
	Repo interface{}
} {
	var calls []struct {
		Repo interface{}
	}
	lockclientWrapperMockloadMRs.RLock()
	calls = mock.calls.loadMRs
	lockclientWrapperMockloadMRs.RUnlock()
	return calls
}

// loadProject calls loadProjectFunc.
func (mock *clientWrapperMock) loadProject(repo interface{}) gitlab.Project {
	if mock.loadProjectFunc == nil {
		panic("clientWrapperMock.loadProjectFunc: method is nil but clientWrapper.loadProject was just called")
	}
	callInfo := struct {
		Repo interface{}
	}{
		Repo: repo,
	}
	lockclientWrapperMockloadProject.Lock()
	mock.calls.loadProject = append(mock.calls.loadProject, callInfo)
	lockclientWrapperMockloadProject.Unlock()
	return mock.loadProjectFunc(repo)
}

// loadProjectCalls gets all the calls that were made to loadProject.
// Check the length with:
//     len(mockedclientWrapper.loadProjectCalls())
func (mock *clientWrapperMock) loadProjectCalls() []struct {
	Repo interface{}
} {
	var calls []struct {
		Repo interface{}
	}
	lockclientWrapperMockloadProject.RLock()
	calls = mock.calls.loadProject
	lockclientWrapperMockloadProject.RUnlock()
	return calls
}
